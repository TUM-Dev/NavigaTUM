{
  "db_name": "PostgreSQL",
  "query": "\nWITH ENTRIES_TO_SCRAPE AS (SELECT KEY,\n                                  CASE WHEN last_calendar_scrape_at IS NULL THEN 100 ELSE 1 END          AS priority,\n                                  CAST(data -> 'ranking_factors' ->> 'rank_combined' AS INTEGER)         AS rank_combined,\n                                  (LAST_CALENDAR_SCRAPE_AT < DATE_SUBTRACT(NOW(), '1 hour'::INTERVAL, 'Europe/Berlin')\n                                      OR LAST_CALENDAR_SCRAPE_AT IS NULL)                                AS would_need_scraping,\n                                  EXTRACT(EPOCH FROM (NOW() - LAST_CALENDAR_SCRAPE_AT)) / 60             AS minutes_ago,\n                                  CALENDAR_URL IS NOT NULL                                               AS can_be_scraped\n                           FROM de)\n\nSELECT key\nFROM entries_to_scrape\nWHERE would_need_scraping AND can_be_scraped\n-- priority: has this ever been scraped? => give a good bonus\n-- rank_combined: \"how important is this room?\" (range 1..1k)\n-- minutes_ago: \"how long since we last scraped it?\" (range null,60..)\nORDER BY priority * rank_combined * coalesce(minutes_ago,1) DESC\nLIMIT 20",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "key",
        "type_info": "Text"
      }
    ],
    "parameters": {
      "Left": []
    },
    "nullable": [
      false
    ]
  },
  "hash": "383cf5a483f09733f5772991237d30544400b6101a7e476def026dd3bd5db56b"
}
